\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix-2020-09}
    
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{filecontents}
\begin{filecontents}{\jobname.bib}
@Book{arpachiDusseau18:osbook,
  author =       {Arpaci-Dusseau, Remzi H. and Arpaci-Dusseau Andrea C.},
  title =        {Operating Systems: Three Easy Pieces},
  publisher =    {Arpaci-Dusseau Books, LLC},
  year =         2015,
  edition =      {1.00},
  note =         {\url{http://pages.cs.wisc.edu/~remzi/OSTEP/}}
}
@InProceedings{waldspurger02,
  author =       {Waldspurger, Carl A.},
  title =        {Memory resource management in {VMware ESX} server},
  booktitle =    {USENIX Symposium on Operating System Design and
                  Implementation (OSDI)},
  year =         2002,
  pages =        {181--194},
  note =         {\url{https://www.usenix.org/legacy/event/osdi02/tech/waldspurger/waldspurger.pdf}}}
\end{filecontents}

\begin{document}
%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Efficient Automated Generation of Password Cracking Rules}

\author{
{\rm Joshua Eckroth}\\
Stetson University
\and
{\rm Lannie Hough}\\
i2k Connect, Inc.
\and
{\rm Hala ElAarag}\\
Stetson University
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
Password cracking tools such as Hashcat support the use of rules that transform
a dictionary of words, such as common English words and previously-cracked
passwords, into new candidate guesses. Rules are necessary to achieve high
cracking ratios, however, they are difficult to build by hand. We have
developed an algorithm and implementation that automatically finds successful
rules by combinatorial generation of rules and empirical observation of how
often each generated rule transforms a dictionary word to a target password.
Our algorithm is efficient and avoids the combinatorial explosion of rules that
would occur if brute force techniques were used. In this paper, we explain our
algorithm in detail and experimentally compare the performance of its outputs to
existing rule sets. We show that our approach is completely automated and
(* achieves comparable cracking performance but with a smaller number of rules,
thus reducing runtime during the cracking process *).
\end{abstract}


%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

difficulty in creating rules by hand

existence of aggregated rule sets (oneruletorulethemall, pantagrule)

password change policies (regular intervals) might encourage people to make
simple modifications to their existing password to create a new one; we want
to find these by trying a trivial (primitive) modification one at a time until
we hit a known password

this approach has benefits because it can find unexpected combinations of
primitive rules that might actually be somewhat common, however this approach
also has the drawback of

%-------------------------------------------------------------------------------
\section{Related Work}
%-------------------------------------------------------------------------------

Footnotes should be places after punctuation characters, without any
spaces between said characters and footnotes, like so.%
\footnote{Remember that USENIX format stopped using endnotes and is
  now using regular footnotes.} And some embedded literal code may
look as follows.

\begin{verbatim}
int main(int argc, char *argv[]) 
{
    return 0;
}
\end{verbatim}

Now we're going to cite somebody. Watch for the cite tag. Here it
comes. Arpachi-Dusseau and Arpachi-Dusseau co-authored an excellent OS
book, which is also really funny~\cite{arpachiDusseau18:osbook}, and
Waldspurger got into the SIGOPS hall-of-fame due to his seminal paper
about resource management in the ESX hypervisor~\cite{waldspurger02}.

The tilde character (\~{}) in the tex source means a non-breaking
space. This way, your reference will always be attached to the word
that preceded it, instead of going to the next line.

And the 'cite' package sorts your citations by their numerical order
of the corresponding references at the end of the paper, ridding you
from the need to notice that, e.g, ``Waldspurger'' appears after
``Arpachi-Dusseau'' when sorting references
alphabetically~\cite{waldspurger02,arpachiDusseau18:osbook}. 

It'd be nice and thoughtful of you to include a suitable link in each
and every bibtex entry that you use in your submission, to allow
reviewers (and other readers) to easily get to the cited work, as is
done in all entries found in the References section of this document.

Now we're going take a look at Section~\ref{sec:figs}, but not before
observing that refs to sections and citations and such are colored and
clickable in the PDF because of the packages we've included.

%-------------------------------------------------------------------------------
\section{Methodology}
\label{sec:methodology}
%-------------------------------------------------------------------------------

Our rule generator requires two inputs: a set of rule primitives that will be combined to form complex rules, and a set of target passwords such as the Rockyou list. We implement an efficient version of what is essentially a brute-force procedure. We first describe the brute-force procedure and then describe our optimizations.

\subsection{Brute-force procedure}

Given each initial target password (e.g., from Rockyou), we apply every primitive rule to the password to generate new passwords. For example, the primitive Hashcat rule `r' (reverse) applied to the initial target password `123456' results in password `654321.' We use a primitive rule set consisting of elementary operations such as reverse (`r'), remove last character (`]'), delete all `s' characters (`@s'), and so on, totaling nearly 400 primitive rules. The selected password is subjected to every primitive, resulting in about 400 new passwords. For each resulting password (such as `654321'), we check if it is one of our targets from our initial list of targets (e.g., Rockyou). If it is, we boost the score of the rule that was applied. In the end, we have a list of rules with scores indicating which rules were most successful.

After that initial step of applying rules to a single password, we proceed to choose another password and apply all primitive rules to it, boosting the scores of rules that transform the password to a known target password. We choose the next password to try according to an ordering of the original target list (e.g., Rockyou sorted by password `strength,' with weaker passwords chosen earlier; details are given below).

Each password that is generated from applying primitive rules becomes a potential candidate itself, unless it is already known from the initial target set. For example, if the rule `r' is applied to `foobar,' producing `raboof,' and `raboof' is not already known from the target set, it becomes a candidate for selection. We record the history of rules that have already been applied, in this case just `r.' When `raboof' is eventually selected as the next password to try, each primitive rule is appended to its rule history, producing complex rules `r ]' `r @s' and so on. If `]' applied to `raboof,' which produces `raboo,' is a target, then we boost the score of the complex rule `r ].' We note that the initial password `foobar' (pulled from Rockyou) was transformed to `raboo' using complex rule `r ]' and `raboo' is a target (in this example, though in reality it is not a member of Rockyou). Thus, our procedure has discovered a successful rule that should be utilized in password cracking.

In summary, the brute-force procedure begins with an initial list of target passwords and puts them into a candidate set, picks a single candidate password at a time and applies all primitive rules, and boosts the scores of any rules that ultimately produced a password found in the initial list of targets. Each password generated from applying rules goes into the candidate set if it is not already in there, and the sequence of primitive rules that generated it is associated with the password.

Figure~\ref{fig:pwgen} shows an example of the combinatorial explosion of candidates that results from the brute-force algorithm.

\subsection{LaTeX-ing Your TeX File}
%-----------------------------------

People often use \texttt{pdflatex} these days for creating pdf-s from
tex files via the shell. And \texttt{bibtex}, of course. Works for us.

%-------------------------------------------------------------------------------
\section*{Acknowledgments}
%-------------------------------------------------------------------------------

The USENIX latex style is old and very tired, which is why
there's no \textbackslash{}acks command for you to use when
acknowledging. Sorry.

%-------------------------------------------------------------------------------
\section*{Availability}
%-------------------------------------------------------------------------------

USENIX program committees give extra points to submissions that are
backed by artifacts that are publicly available. If you made your code
or data available, it's worth mentioning this fact in a dedicated
section.

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
